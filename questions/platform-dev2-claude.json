[
    {
            "question": "A developer needs to implement an asynchronous process to be executed when a Case record is updated. The process needs to run with system permissions and must handle bulk updates efficiently. Which two features should the developer consider?",
      "options": [
        "Trigger and @future method",
        "Platform Event and trigger",
        "Apex REST service and callout",
        "Batch Apex and Database.Stateful",
        "Queueable Apex and trigger"
      ],
      "correctAnswer": ["Platform Event and trigger", "Queueable Apex and trigger"],
      "explanation": "Comprehensive test coverage requires testing both positive scenarios (where the code should succeed) and negative scenarios (where it should fail or handle exceptions). Each test should include specific assertions that verify the expected behavior. This approach ensures the code works correctly under various conditions and maintains its integrity when modified."
    },
    {
      
      "question": "A developer needs to implement a solution that allows administrators to create custom validation rules without writing code. Which approach should be used?",
      "options": [
        "Create an Apex class with dynamic SOQL",
        "Implement a Custom Metadata Type with validation logic",
        "Use Custom Settings with a Visualforce page",
        "Create a Lightning Web Component with configurable rules",
        "Implement a Flow with Invocable Actions"
      ],
      "correctAnswer": ["Implement a Custom Metadata Type with validation logic"],
      "explanation": "Custom Metadata Types are ideal for creating configurable validation rules that administrators can manage without code changes. By storing validation criteria in Custom Metadata records, the Apex code can dynamically apply these rules at runtime, allowing for admin-configurable validation logic."
    },
    {
      
      "question": "A developer is implementing a complex data model with multiple related objects. Which statement about junction objects is true?",
      "options": [
        "A junction object must have two master-detail relationships",
        "A junction object can have at most one lookup relationship",
        "A junction object requires a custom index on related fields",
        "A junction object cannot be used in SOQL relationship queries",
        "A junction object must be created through the API"
      ],
      "correctAnswer": ["A junction object must have two master-detail relationships"],
      "explanation": "A junction object in Salesforce is used to build a many-to-many relationship between two objects. It must have two master-detail relationships, one to each of the objects it connects. This allows for the creation of many-to-many relationships while maintaining referential integrity."
    },
    {
      
      "question": "A developer needs to implement a solution that executes a sequence of operations, where each operation might succeed or fail independently. Which pattern should be implemented?",
      "options": [
        "Chain of Responsibility Pattern",
        "Command Pattern",
        "Observer Pattern",
        "Decorator Pattern",
        "Saga Pattern"
      ],
      "correctAnswer": ["Saga Pattern"],
      "explanation": "The Saga Pattern is designed for managing sequences of operations where each step might succeed or fail independently. It includes compensating transactions to handle failures at any point in the sequence. This pattern is ideal for complex processes that need to maintain consistency across multiple operations."
    },
    {
      
      "question": "A developer needs to implement a custom UI for a complex form that includes conditional logic and dynamic field validation. Which approach should be used?",
      "options": [
        "Use Standard Lightning Record Pages with Dynamic Forms",
        "Implement a Flow with Screen Components",
        "Create a Visualforce Page with Custom Controller",
        "Use Lightning Web Components with Custom Rendering",
        "Implement Quick Actions with Predefined Field Values"
      ],
      "correctAnswer": ["Create a Visualforce Page with Custom Controller"],
      "explanation": "For complex forms with conditional logic and dynamic field validation, a Visualforce Page with a Custom Controller provides the most flexibility. This approach allows for custom rendering, complex validation logic, and dynamic UI components that respond to user input and data conditions."
    },
    {
      
      "question": "A developer needs to implement a solution that performs a calculation on all Opportunity records that meet specific criteria. The calculation needs to run on a regular schedule. Which approach should be used?",
      "options": [
        "Create a Scheduled Apex class",
        "Use a Workflow Rule with field updates",
        "Implement a Batch Apex job with Database.Batchable",
        "Create a Lightning Web Component with a timer",
        "Use Process Builder with scheduled actions"
      ],
      "correctAnswer": ["Create a Scheduled Apex class"],
      "explanation": "A Scheduled Apex class is ideal for running regular calculations on records that meet specific criteria. By implementing the Schedulable interface, the class can be scheduled to run at specific intervals, ensuring the calculations are performed regularly without manual intervention."
    },
    {
      
      "question": "A developer needs to design a data model for a recruitment application where each candidate can apply for multiple positions, and each position can have multiple applicants. Which data model approach should be used?",
      "options": [
        "Create a lookup relationship from Candidate to Position",
        "Create a master-detail relationship from Position to Candidate",
        "Create a junction object with master-detail relationships to both objects",
        "Create a multi-select picklist on Candidate for Positions",
        "Create a custom field of type 'Relation' on both objects"
      ],
      "correctAnswer": ["Create a junction object with master-detail relationships to both objects"],
      "explanation": "For a many-to-many relationship like candidates applying for multiple positions and positions having multiple applicants, a junction object with master-detail relationships to both the Candidate and Position objects is the appropriate data model. This approach properly represents the many-to-many relationship while maintaining data integrity."
    },
    {
      
      "question": "A developer is implementing a Lightning Web Component that needs to expose a method to be called from a parent component. How should this method be defined?",
      "options": [
        "Use the @track decorator on the method",
        "Use the @api decorator on the method",
        "Use the @wire decorator on the method",
        "Make the method static and public",
        "Use the @AuraEnabled decorator on the method"
      ],
      "correctAnswer": ["Use the @api decorator on the method"],
      "explanation": "The @api decorator is used to expose properties and methods of a Lightning Web Component to other components. When applied to a method, it makes that method callable from parent components, allowing for component composition and communication from parent to child."
    },
    {
      
      "question": "A developer needs to create a Lightning Web Component that requires different behavior based on the user's profile. Which approach should be used?",
      "options": [
        "Use a custom permission set for each profile",
        "Create different components for each profile",
        "Use User.Profile in the Apex controller",
        "Implement $UserRole global variable in JavaScript",
        "Use the Id.getSObjectType() method"
      ],
      "correctAnswer": ["Use User.Profile in the Apex controller"],
      "explanation": "To implement profile-based behavior in a Lightning Web Component, the developer should use an Apex controller that checks the current user's profile (User.Profile) and returns appropriate data or flags to the component. This allows the component to render differently or behave differently based on the user's profile."
    },
    {
      
      "question": "A developer needs to implement a solution that processes records in chunks to avoid hitting governor limits. Which feature should be used?",
      "options": [
        "Schedulable Interface",
        "Batchable Interface",
        "Queueable Interface",
        "Callable Interface",
        "Invocable Method"
      ],
      "correctAnswer": ["Batchable Interface"],
      "explanation": "The Batchable Interface (Database.Batchable) is specifically designed for processing records in chunks or batches. It automatically handles chunking the data and provides methods (start, execute, finish) that work with these chunks, making it ideal for processing large volumes of data while avoiding governor limits."
    },
    {
      
      "question": "A developer needs to implement a solution that makes callouts to an external system based on changes to Salesforce records. Which limitation must be addressed in the design?",
      "options": [
        "Callouts cannot be made from triggers directly",
        "Callouts are limited to 100 per transaction",
        "Callouts require Named Credentials",
        "Callouts must use the SOAP API",
        "Callouts require a Connected App"
      ],
      "correctAnswer": ["Callouts cannot be made from triggers directly"],
      "explanation": "When designing solutions that involve callouts based on record changes, it's important to remember that callouts cannot be made directly from triggers. This is because triggers run in the same transaction context, and Salesforce prevents callouts during the same transaction to avoid long-running transactions. Instead, asynchronous Apex (like @future, Queueable, or Batch) must be used to make the callouts."
    },
    {
      
      "question": "A developer needs to implement custom search functionality that searches across multiple text fields and returns results sorted by relevance. Which approach should be used?",
      "options": [
        "Use multiple SOQL queries with LIKE operators",
        "Implement SOSL with the RETURNING clause",
        "Create a custom Visualforce page with controller",
        "Use Lightning Data Service with filters",
        "Implement a Flow with dynamic picklists"
      ],
      "correctAnswer": ["Implement SOSL with the RETURNING clause"],
      "explanation": "SOSL (Salesforce Object Search Language) is optimized for text searches across multiple fields and objects. With the RETURNING clause, it can specify which objects and fields to search and return results sorted by relevance. This makes it ideal for implementing custom search functionality that needs to search multiple text fields."
    },
    {
      
      "question": "A developer needs to implement a solution that processes large volumes of data through multiple steps, with the ability to restart processing from the last successful step if a failure occurs. Which pattern should be implemented?",
      "options": [
        "Checkpoint Pattern",
        "Chain of Responsibility Pattern",
        "Circuit Breaker Pattern",
        "Bulkhead Pattern",
        "Decorator Pattern"
      ],
      "correctAnswer": ["Checkpoint Pattern"],
      "explanation": "The Checkpoint Pattern involves saving the state of processing at regular intervals (checkpoints) so that if a failure occurs, processing can be resumed from the last successful checkpoint rather than starting from the beginning. This pattern is particularly useful for large data volume processing that involves multiple steps and may encounter failures."
    },
    {
      
      "question": "A developer is designing a solution that requires secure storage of sensitive API keys and credentials that will be used in Apex code. Which approach provides the highest level of security?",
      "options": [
        "Store the credentials in a Static Resource",
        "Use Custom Settings with Protected fields",
        "Use Named Credentials with Password Authentication",
        "Store the credentials in a Custom Metadata Type",
        "Use a Custom Object with field-level security"
      ],
      "correctAnswer": ["Use Named Credentials with Password Authentication"],
      "explanation": "Named Credentials provide a secure way to store and manage authentication details for callouts to external systems. They support various authentication protocols and securely store credentials, which are then automatically used when making callouts. This approach prevents credentials from being exposed in code and provides superior security for API keys and credentials."
    },
    {
      
      "question": "A developer needs to create a solution that allows admins to define complex approval processes with multiple levels of approval based on various criteria. Which approach should be used?",
      "options": [
        "Use standard Approval Processes with entry criteria",
        "Create a custom Apex class with dynamic approvals",
        "Implement a Visual Workflow with approval steps",
        "Use Process Builder with approval actions",
        "Create a custom Lightning component for approvals"
      ],
      "correctAnswer": ["Use standard Approval Processes with entry criteria"],
      "explanation": "Standard Approval Processes in Salesforce are designed for exactly this scenario. They support multiple approval levels, complex entry criteria, and various routing options, all configurable by administrators without code. This declarative approach is the most appropriate for defining complex approval processes with multiple levels."
    },
    {
      
      "question": "A developer needs to implement a solution that retrieves data from an external system and transforms it into a format compatible with Salesforce objects. Which tool should be used?",
      "options": [
        "Data Loader",
        "ETL Tool",
        "External Services",
        "Change Data Capture",
        "Custom Apex Integration"
      ],
      "correctAnswer": ["Custom Apex Integration"],
      "explanation": "For complex integration scenarios requiring data retrieval from external systems and transformation before loading into Salesforce, a Custom Apex Integration provides the most flexibility. This approach allows for custom callouts, complex data manipulation, and precise control over how the external data maps to Salesforce objects."
    },
    {
      
      "question": "A developer needs to implement a solution that allows filtering and sorting of data in a Lightning Web Component. Which approach should be used?",
      "options": [
        "Use the lightning-datatable component with sortable columns",
        "Implement a custom JavaScript sorting algorithm",
        "Use SOQL ORDER BY and WHERE clauses in the Apex controller",
        "Implement the Comparable interface in Apex",
        "Use Lightning Data Service with filters"
      ],
      "correctAnswer": ["Use the lightning-datatable component with sortable columns"],
      "explanation": "The lightning-datatable component is specifically designed for displaying data in a tabular format with built-in support for filtering and sorting. By configuring columns as sortable, users can click column headers to sort data, and the component handles the sorting logic automatically, providing a responsive and interactive user experience."
    },
    {
      
      "question": "A developer needs to implement a solution where changes to an object in Salesforce automatically trigger updates to related objects across multiple Salesforce orgs. Which feature should be used?",
      "options": [
        "Outbound Message with Workflow",
        "Change Data Capture with subscribers",
        "Platform Events with publish-subscribe",
        "Streaming API with PushTopic",
        "Apex callout with @future annotation"
      ],
      "correctAnswer": ["Platform Events with publish-subscribe"],
      "explanation": "Platform Events with a publish-subscribe model are ideal for integrating multiple Salesforce orgs. When changes occur in one org, a Platform Event can be published, and subscriber code in other orgs can listen for these events and perform corresponding updates. This approach provides near real-time synchronization across multiple orgs."
    },
    {
      
      "question": "A developer needs to implement a solution that allows users to upload and process large CSV files with millions of records. Which approach should be used?",
      "options": [
        "Use the standard Data Import Wizard",
        "Create a Visualforce page with an InputFile component",
        "Implement a Lightning Web Component with the lightning-file-upload component",
        "Use Data Loader with command line interface",
        "Create a custom solution using the Bulk API"
      ],
      "correctAnswer": ["Create a custom solution using the Bulk API"],
      "explanation": "For processing very large files with millions of records, a custom solution using the Bulk API is the most appropriate. The Bulk API is designed specifically for processing large data volumes efficiently, handling chunking, parallelization, and governor limits automatically. A custom solution can provide the necessary UI for file upload and status monitoring."
    },
    {
      
      "question": "A developer needs to create an Apex method that can be called from a Flow. How should this method be defined?",
      "options": [
        "Use the @AuraEnabled annotation",
        "Use the @InvocableMethod annotation",
        "Make the method global and static",
        "Use the @future annotation",
        "Implement the Callable interface"
      ],
      "correctAnswer": ["Use the @InvocableMethod annotation"],
      "explanation": "To expose an Apex method for use in Flows, the @InvocableMethod annotation must be used. This annotation makes the method callable from Flow and Process Builder, allowing for complex logic to be encapsulated in Apex and then invoked from declarative tools."
    },
    {
      
      "question": "A developer needs to implement a solution where updates to a custom object trigger complex processing that may take several minutes to complete. Which approach should be used?",
      "options": [
        "Use a trigger with @future methods",
        "Implement Batch Apex with a small batch size",
        "Create a Queueable Apex class",
        "Use Process Builder with Flow actions",
        "Implement a scheduled Apex job"
      ],
      "correctAnswer": ["Create a Queueable Apex class"],
      "explanation": "Queueable Apex is ideal for long-running operations triggered by record updates. Unlike @future methods, Queueable Apex supports complex types, can be chained, and provides more control over execution. It runs asynchronously, allowing the triggering transaction to complete quickly while the complex processing continues in a separate context."
    },
    {
      
      "question": "A developer is designing a Lightning Web Component that needs to track the state of multiple variables and update the UI when any of them change. Which mechanism should be used?",
      "options": [
        "Use public properties with getters and setters",
        "Implement the @track decorator",
        "Use the @api decorator for all variables",
        "Store variables in localStorage",
        "Use static variables in the JavaScript controller"
      ],
      "correctAnswer": ["Implement the @track decorator"],
      "explanation": "The @track decorator in Lightning Web Components is used to track changes to a property's value. When a tracked property changes, the component automatically rerenders to reflect those changes in the UI. This makes it ideal for tracking the state of multiple variables that affect the component's UI."
    },
    {
      
      "question": "A developer needs to implement a solution that validates data against complex business rules before saving. Which two approaches provide the most flexibility?",
      "options": [
        "Use validation rules with formula expressions",
        "Implement Apex triggers with custom validation logic",
        "Create Process Builder flows with validation conditions",
        "Use standard field validation with regular expressions",
        "Implement a custom Visualforce page with controller validation"
      ],
      "correctAnswer": ["Implement Apex triggers with custom validation logic", "Implement a custom Visualforce page with controller validation"],
      "explanation": "For complex business rule validation, Apex triggers provide the most flexibility, allowing for custom logic, cross-object validation, and dynamic rules. Similarly, custom Visualforce pages with controller validation provide client-side and server-side validation capabilities with full control over the validation logic and user experience. Both approaches offer maximum flexibility for implementing complex business rules."
    },
    {
      
      "question": "A developer needs to implement a solution that records detailed information about changes to specific fields on opportunities. Which approach requires the least custom development?",
      "options": [
        "Create an Apex trigger to track field history",
        "Use Field Audit Trail",
        "Implement a Process Builder flow with record creates",
        "Create a custom history object with a master-detail relationship",
        "Use the standard History related list"
      ],
      "correctAnswer": ["Use Field Audit Trail"],
      "explanation": "Field Audit Trail is a built-in feature that extends Field History Tracking by allowing for longer retention of field history data and tracking of more fields. It requires minimal setup and no custom development, making it the approach that requires the least custom development effort for recording detailed field change information."
    },
    {
      
      "question": "A developer is building a Lightning Web Component that requires complex data manipulation before displaying it to users. Where should this data manipulation logic be implemented?",
      "options": [
        "In the component's JavaScript controller",
        "In the component's HTML template",
        "In a separate JavaScript library",
        "In an Apex controller class",
        "In a custom metadata type"
      ],
      "correctAnswer": ["In an Apex controller class"],
      "explanation": "Complex data manipulation is best implemented in an Apex controller class. Apex has access to the full Salesforce data model, powerful data manipulation capabilities, and can handle larger data volumes than client-side JavaScript. The processed data can then be passed to the Lightning Web Component for display."
    },
    {
      
      "question": "A developer needs to implement a solution that executes a process after a user submits a form, but the process may take several minutes to complete. Which approach provides the best user experience?",
      "options": [
        "Use a synchronous Apex method and display a loading spinner",
        "Implement an asynchronous process with a callback",
        "Use a @future method and refresh the page when complete",
        "Create a queueable job with status notifications",
        "Implement a batch job with email notifications"
      ],
      "correctAnswer": ["Create a queueable job with status notifications"],
      "explanation": "For long-running processes triggered by user actions, a queueable job with status notifications provides the best user experience. The form submission can quickly queue the job and return control to the user with an acknowledgment. Status notifications (via platform events, polling, or completion notifications) keep the user informed about progress without requiring them to wait for completion."
    },
    {
      
      "question": "A developer needs to implement a solution that aggregates data from multiple objects for reporting purposes. Which approach requires the least custom code?",
      "options": [
        "Create a custom object with Apex triggers for aggregation",
        "Use SOQL with aggregate functions in a Visualforce page",
        "Implement a custom report type with joined objects",
        "Create a custom Lightning Web Component with Apex controller",
        "Use Process Builder with record updates"
      ],
      "correctAnswer": ["Implement a custom report type with joined objects"],
      "explanation": "Custom Report Types with joined objects allow for creating reports that aggregate data across related objects without requiring custom code. This declarative approach enables administrators to define relationships between objects and specify which fields should be available for reporting, making it the approach that requires the least custom code."
    },
    {
      
      "question": "A developer needs to implement a solution that automatically calculates commissions for sales representatives based on opportunity amounts and product mix. Which feature should be used?",
      "options": [
        "Roll-up Summary Fields",
        "Validation Rules",
        "Workflow Field Updates",
        "Apex Triggers",
        "Process Builder"
      ],
      "correctAnswer": ["Apex Triggers"],
      "explanation": "Commission calculations based on opportunity amounts and product mix typically involve complex business logic that considers multiple factors. Apex Triggers provide the necessary flexibility and computational capabilities to implement such complex calculations, especially when they involve the product mix, which may require querying related product records and applying varying commission rates."
    },
    {
      
      "question": "A developer needs to implement a solution where users can search for records across multiple objects with complex filtering criteria. Which approach should be used?",
      "options": [
        "Use standard Search functionality with Sidebar Search",
        "Implement SOSL with complex WHERE clauses",
        "Create a custom Visualforce page with controller",
        "Use Lightning Data Service with filters",
        "Implement a Lightning Web Component with custom search logic"
      ],
      "correctAnswer": ["Implement a Lightning Web Component with custom search logic"],
      "explanation": "For complex search functionality with custom filtering across multiple objects, a Lightning Web Component with custom search logic provides the most flexibility. This approach allows for implementing a tailored user interface and leveraging both SOQL and SOSL in the backend to create a powerful search experience that meets specific requirements."
    },
    {
      
      "question": "A developer needs to implement a solution that requires tracking field values at the time an opportunity is closed. Which approach should be used?",
      "options": [
        "Use Field History Tracking",
        "Create a snapshot object with a trigger",
        "Implement a process with record creates",
        "Use a workflow rule with field updates",
        "Create a roll-up summary field"
      ],
      "correctAnswer": ["Create a snapshot object with a trigger"],
      "explanation": "For tracking field values at specific points in a record's lifecycle (like when an opportunity is closed), creating a snapshot object with an Apex trigger is the most appropriate solution. This approach allows for capturing and storing the exact state of the record at the moment the specified condition occurs, providing a reliable historical record for future reference."
    },
    {
      
      "question": "A developer is building a Lightning Web Component that needs to retrieve data based on the current user's context. Which mechanism should be used to get the current user's information?",
      "options": [
        "Use the $User global variable in the component markup",
        "Implement the UserInfo class in an Apex controller",
        "Use the lightning-user-profile component",
        "Create a custom metadata type for user information",
        "Use the Identity API in JavaScript"
      ],
      "correctAnswer": ["Implement the UserInfo class in an Apex controller"],
      "explanation": "To retrieve the current user's context in a Lightning Web Component, the UserInfo class in an Apex controller should be used. This provides access to important user information like Id, ProfileId, and other attributes that may be needed for data retrieval or access control, while maintaining security by handling sensitive operations on the server."
    },
    {
      
      "question": "A developer needs to implement a solution that converts lead records into accounts, contacts, and opportunities with custom mapping logic. Which approach should be used?",
      "options": [
        "Use standard lead conversion with custom lead settings",
        "Create a Process Builder flow with record creates",
        "Implement a custom Visualforce page with controller",
        "Use the LeadConvert Apex class",
        "Implement a Lightning Web Component with Apex controller"
      ],
      "correctAnswer": ["Use the LeadConvert Apex class"],
      "explanation": "The LeadConvert Apex class (specifically, the Database.LeadConvert class) is designed for implementing custom lead conversion logic. It provides methods for specifying custom field mappings, controlling which objects are created, and handling the conversion process programmatically, making it the appropriate choice for custom lead conversion requirements."
    },
    {
      
      "question": "A developer needs to implement a solution that monitors changes to specific fields on Account records and sends notifications to interested users. Which feature should be used?",
      "options": [
        "Workflow Email Alerts",
        "Process Builder with email actions",
        "Streaming API with PushTopics",
        "Apex Triggers with Messaging.sendEmail",
        "Platform Events with subscribers"
      ],
      "correctAnswer": ["Streaming API with PushTopics"],
      "explanation": "The Streaming API with PushTopics is designed for real-time monitoring of record changes. By defining a PushTopic that specifies the fields to monitor on Account records, interested users can subscribe to receive notifications when those fields change, providing a real-time notification system without requiring constant polling."
    },
    {
      
      "question": "A developer needs to implement a solution that performs complex calculations on large data sets with optimal performance. Which approach should be used?",
      "options": [
        "Use formula fields with advanced functions",
        "Implement roll-up summary fields with filters",
        "Create Apex triggers with bulk processing",
        "Use Process Builder with custom invocable actions",
        "Implement a scheduled batch job"
      ],
      "correctAnswer": ["Implement a scheduled batch job"],
      "explanation": "For complex calculations on large data sets, a scheduled batch job provides optimal performance by processing data in manageable chunks. This approach avoids governor limits, can run during off-peak hours to minimize impact on users, and can be optimized for specific data processing patterns, making it ideal for resource-intensive calculations on large data volumes."
    },
    {
      
      "question": "A developer needs to implement a solution that enforces a specific sequence of steps in a business process. Which feature should be used?",
      "options": [
        "Path component",
        "Record Types",
        "Visual Workflow",
        "Stage picklist with validation",
        "Lightning Process Builder"
      ],
      "correctAnswer": ["Path component"],
      "explanation": "The Path component is specifically designed for guiding users through a sequence of steps in a business process. It provides a visual representation of the process, highlights the current stage, and can include guidance for each step. Combined with validation rules or automation, it can enforce that users follow the defined sequence."
    },
    {
      
      "question": "A developer needs to create a data model for a system where multiple teams can collaborate on an account, with each team having different access levels to account information. Which feature should be used?",
      "options": [
        "Record Types",
        "Account Teams",
        "Public Groups",
        "Role Hierarchy",
        "Permission Sets"
      ],
      "correctAnswer": ["Account Teams"],
      "explanation": "Account Teams are designed specifically for scenarios where multiple users need different levels of access to account records. They allow defining custom roles for team members and specifying access levels (Read, Edit, Delete) for each team member, supporting collaborative work while maintaining appropriate access controls."
    },
    {
      
      "question": "A developer needs to implement a solution that synchronizes product information between Salesforce and an external e-commerce system. The synchronization should happen automatically whenever a product is updated in either system. Which approach should be used?",
      "options": [
        "Use Batch Apex with a scheduled job",
        "Implement Outbound Messages with workflow",
        "Create a middleware solution with APIs",
        "Use Change Data Capture with event subscribers",
        "Implement a Queueable Apex job"
      ],
      "correctAnswer": ["Create a middleware solution with APIs"],
      "explanation": "For bidirectional synchronization between Salesforce and an external system, a middleware solution using APIs is the most robust approach. The middleware can listen for changes in both systems, transform data as needed, and ensure that updates are properly synchronized in both directions, with conflict resolution and error handling capabilities."
    },
    {
      
      "question": "A developer needs to implement a solution where users can select multiple records in a list view and perform a custom action on them. Which feature should be used?",
      "options": [
        "Custom List Button",
        "Quick Action",
        "List View Button",
        "Mass Quick Action",
        "Lightning Web Component with List View API"
      ],
      "correctAnswer": ["Lightning Web Component with List View API"],
      "explanation": "For implementing custom actions on multiple records selected in a list view, a Lightning Web Component with the List View API is the most flexible approach. This combination allows for capturing the selected record IDs, implementing custom processing logic, and providing feedback to users, all within a modern and responsive user interface."
    },
    {
      
      "question": "A developer needs to perform DML operations on multiple sObjects of different types in a single transaction. Which approach should be used?",
      "options": [
        "Use individual DML statements for each sObject type",
        "Implement Database.insert() for each list of sObjects",
        "Use the merge statement for all sObjects",
        "Create a wrapper class that implements Database.Batchable",
        "Use the Database.SaveResult class with different sObject types"
      ],
      "correctAnswer": ["Use individual DML statements for each sObject type"],
      "explanation": "For performing DML operations on multiple sObjects of different types in a single transaction, individual DML statements for each sObject type must be used. Unlike some other database systems, Salesforce DML operations (insert, update, delete, upsert) can only work with sObjects of the same type in a single operation. Multiple DML statements can still be part of the same transaction."
    },
    {
      
      "question": "A developer needs to implement a solution where certain fields on a custom object should only be editable by users with a specific permission. Which approach should be used?",
      "options": [
        "Use field-level security with profiles",
        "Create a record-triggered flow with conditions",
        "Implement a validation rule with $Permission",
        "Use a custom permission with Apex security",
        "Create a custom Lightning component with access checks"
      ],
      "correctAnswer": ["Implement a validation rule with $Permission"],
      "explanation": "To control field editability based on custom permissions, a validation rule using the $Permission global variable is the most direct approach. The rule can check if the user has a specific custom permission and prevent edits to certain fields if they don't, without requiring custom code or complex configurations."
    },
    {
      
      "question": "A developer needs to implement a solution that uses an external service for credit card processing with robust error handling. Which pattern should be implemented?",
      "options": [
        "Circuit Breaker Pattern",
        "Singleton Pattern",
        "Factory Pattern",
        "Repository Pattern",
        "Observer Pattern"
      ],
      "correctAnswer": ["Circuit Breaker Pattern"],
      "explanation": "The Circuit Breaker Pattern is ideal for integrations with external services like credit card processing. It monitors for failures and, when a failure threshold is reached, 'trips' the circuit to prevent continuous failed requests. This pattern provides robust error handling, prevents resource exhaustion during outages, and allows for graceful degradation of functionality."
    },
    {
            "question": "A developer needs to build a complex app with multiple UI components that need to communicate with each other. Which design pattern should be implemented?",
      "options": [
        "Singleton Pattern",
        "Factory Pattern",
        "Observer Pattern",
        "Strategy Pattern",
        "Decorator Pattern"
      ],
      "correctAnswer": ["Observer Pattern"],
      "explanation": "The Observer Pattern is ideal when multiple components need to communicate with each other. In Lightning components, this is typically implemented using the Lightning Message Service or component events. This pattern allows components to subscribe to and react to events without being tightly coupled."
    },
    {
            "question": "A developer needs to implement a solution that processes records in batches of 200 and maintains state between batches. Which implementation would meet these requirements?",
      "options": [
        "Use a global variable in a Batch Apex class",
        "Use a static variable in a Batch Apex class",
        "Implement Database.Stateful in a Batch Apex class",
        "Implement Database.AllowsCallouts in a Batch Apex class",
        "Use a custom setting to store state information"
      ],
      "correctAnswer": ["Implement Database.Stateful in a Batch Apex class"],
      "explanation": "The Database.Stateful interface allows instance variables to maintain their values between batch executions. This allows the Batch Apex to maintain state between batches. The batch size can be set to 200 using the scope parameter in the Database.executeBatch method."
    },
    {
            "question": "A developer needs to test an Apex class that makes callouts to an external system. Which approach should be used to mock the callouts in the test class?",
      "options": [
        "Use Test.setMock(HttpCalloutMock.class, new MockHttpResponseGenerator())",
        "Use Test.setMock(WebServiceMock.class, new MockWebService())",
        "Use System.runAs(user) to simulate different users making the callout",
        "Use Test.loadData to load test data for the callout",
        "Use @isTest(SeeAllData=true) to access the actual external system"
      ],
      "correctAnswer": ["Use Test.setMock(HttpCalloutMock.class, new MockHttpResponseGenerator())", "Use Test.setMock(WebServiceMock.class, new MockWebService())"],
      "explanation": "For HTTP callouts, Test.setMock(HttpCalloutMock.class, new MockImplementation()) should be used. For SOAP web service callouts, Test.setMock(WebServiceMock.class, new MockImplementation()) should be used. Both approaches allow testing callouts without actually making calls to external systems."
    },
    {
            "question": "A developer needs to implement a solution that creates tasks related to Accounts when certain criteria are met. The solution must be maintainable by system administrators without code changes. Which implementation should be used?",
      "options": [
        "Apex trigger on Account object",
        "Process Builder with Flow",
        "Scheduled Apex job",
        "Visual Workflow",
        "Lightning component with Apex controller"
      ],
      "correctAnswer": ["Process Builder with Flow"],
      "explanation": "Process Builder with Flow allows system administrators to create, manage, and maintain business processes without writing code. This declarative approach can detect when criteria are met on the Account object and create related tasks, all without requiring code modifications by a developer."
    },
    {
            "question": "A developer is building a custom Lightning web component that needs to display data from multiple related objects. Which approach provides the most efficient way to retrieve this data?",
      "options": [
        "Use multiple @wire methods to retrieve data from each object",
        "Use a single Apex method with SOQL that includes relationship queries",
        "Use Lightning Data Service for each object",
        "Use multiple imperative Apex calls in connectedCallback()",
        "Use a Platform Event to publish and subscribe to the data"
      ],
      "correctAnswer": ["Use a single Apex method with SOQL that includes relationship queries"],
      "explanation": "Using a single Apex method with SOQL and relationship queries (using the parent-child or child-parent relationship syntax) is the most efficient approach. This minimizes the number of server roundtrips and allows for optimized querying of related data in a single transaction."
    },
    {
            "question": "A developer is creating a batch job that needs to process millions of records. The job is hitting governor limits. Which two techniques should be used to optimize the batch job?",
      "options": [
        "Set the batch size to the maximum of 2000 records",
        "Set the batch size to a smaller number like 100 or 200 records",
        "Use System.scheduleBatch to stagger the processing over time",
        "Use Database.executeBatch with the optional scope parameter",
        "Add a LIMIT clause to the query locator"
      ],
      "correctAnswer": ["Set the batch size to a smaller number like 100 or 200 records", "Use Database.executeBatch with the optional scope parameter"],
      "explanation": "When processing large volumes of data, using a smaller batch size (through the scope parameter of Database.executeBatch) helps avoid hitting governor limits by processing fewer records per transaction. Additionally, explicitly setting the batch size allows for better control over resource consumption and can help prevent hitting limits."
    },
    {
            "question": "Which two statements are true about Apex managed sharing?",
      "options": [
        "It allows developers to share records with specific users programmatically",
        "It requires the organization-wide default to be set to Private",
        "It automatically recalculates sharing when related records are modified",
        "It can be used to restrict data visibility beyond what's allowed by profiles",
        "It persists after a record's owner is changed"
      ],
      "correctAnswer": ["It allows developers to share records with specific users programmatically", "It persists after a record's owner is changed"],
      "explanation": "Apex managed sharing allows developers to programmatically share records with specific users or groups using Apex. These sharing rules persist even when the record owner changes, unlike owner-based sharing which is automatically recalculated. Apex managed sharing does not require specific organization-wide defaults, though it's most useful in restrictive sharing models."
    },
    {
            "question": "A developer needs to implement a solution where an Apex class can be used for both synchronous and asynchronous processing. Which pattern should be implemented?",
      "options": [
        "Create separate methods for synchronous and asynchronous processing",
        "Implement the Queueable interface and check if the context is synchronous",
        "Use an @future annotation with a parameter to determine processing type",
        "Create a factory class that returns the appropriate implementation",
        "Implement the Batchable interface with a custom scope"
      ],
      "correctAnswer": ["Create a factory class that returns the appropriate implementation"],
      "explanation": "A factory pattern is ideal for this scenario. The factory class would evaluate the context and return either a synchronous or asynchronous implementation. This provides a clean separation of concerns and allows the calling code to be unaware of which implementation is being used."
    },
    {
      
      "question": "A developer is creating a Lightning Web Component that needs to be widely reusable across the organization. Which dependency injection approach should be used to enhance reusability?",
      "options": [
        "Use a static resource to store configuration values",
        "Use @api properties to accept parameters from parent components",
        "Use Lightning Message Service to communicate with other components",
        "Use an Apex controller with required parameters",
        "Use metadata types to store configuration values"
      ],
      "correctAnswer": ["Use @api properties to accept parameters from parent components"],
      "explanation": "Using @api properties (public properties) allows the component to accept values from parent components, making it highly configurable and reusable. This approach aligns with dependency injection principles, where dependencies are provided from outside rather than created within the component."
    },
    {
      
      "question": "A developer is writing a test class for an Apex trigger on the Account object. The trigger relies on a custom setting for configuration. How should the developer ensure that the test has access to the required custom setting?",
      "options": [
        "Use @isTest(SeeAllData=true) annotation",
        "Create the custom setting records in the test setup method",
        "Use Test.getStandardPricebookId() to access the custom setting",
        "Query the custom setting in the test method",
        "Use System.runAs() to access the custom setting"
      ],
      "correctAnswer": ["Create the custom setting records in the test setup method"],
      "explanation": "Custom settings should be created in the test setup method. This approach ensures that the test has the necessary configuration data without relying on existing data in the org, which is a best practice for test isolation and predictability."
    },
    {
      
      "question": "A developer needs to implement a solution that processes records in near real-time when changes occur to an external system. Which integration pattern should be used?",
      "options": [
        "Remote Process Invocation—Request and Reply",
        "Batch Data Synchronization",
        "Remote Process Invocation—Fire and Forget",
        "Data Virtualization",
        "UI Update Based on Data Changes"
      ],
      "correctAnswer": ["Remote Process Invocation—Fire and Forget"],
      "explanation": "The Remote Process Invocation—Fire and Forget pattern is appropriate when an external system needs to trigger processing in Salesforce without waiting for a response. This pattern supports near real-time processing of records when external changes occur, typically implemented using Platform Events or Apex REST endpoints."
    },
    {
      
      "question": "A developer needs to distribute processing of large data volumes across multiple processing units. Which feature would be most appropriate to use?",
      "options": [
        "Batch Apex with multiple batches",
        "Queueable chain jobs",
        "Parallel Apex using the @future annotation",
        "Process Builder with multiple processes",
        "Apex Flex Queue"
      ],
      "correctAnswer": ["Batch Apex with multiple batches"],
      "explanation": "Batch Apex is designed to handle large data volumes by breaking processing into manageable chunks. By setting an appropriate batch size and leveraging multiple batches, the processing can be distributed efficiently across multiple processing units while respecting governor limits."
    },
    {
      
      "question": "A developer needs to implement a solution that securely stores sensitive customer data within Salesforce. Which approach provides the highest level of security for this data?",
      "options": [
        "Use field-level security and store the data in encrypted custom fields",
        "Use Shield Platform Encryption and encrypt the fields at rest",
        "Store the data in a protected custom setting",
        "Use Apex crypto methods to encrypt values before storing",
        "Store the data in external objects using oAuth authentication"
      ],
      "correctAnswer": ["Use Shield Platform Encryption and encrypt the fields at rest"],
      "explanation": "Shield Platform Encryption provides the highest level of security by encrypting data at rest while preserving application functionality. It encrypts data stored in the database, search indexes, and file attachments, making it the most comprehensive solution for protecting sensitive customer data within Salesforce."
    },
    {
      
      "question": "A developer is creating a custom search functionality that needs to search for records across multiple objects based on specific criteria. Which approach would be most efficient?",
      "options": [
        "Use multiple SOQL queries with dynamic binding",
        "Implement the Search.query() method with a complex SOSL query",
        "Create custom indexes on the objects and use Schema.describeSObjects()",
        "Use a batch Apex job to search through all objects",
        "Implement a custom Lightning component with multiple @wire services"
      ],
      "correctAnswer": ["Implement the Search.query() method with a complex SOSL query"],
      "explanation": "SOSL (Salesforce Object Search Language) is specifically designed for text-based searches across multiple objects simultaneously. Using Search.query() with a well-constructed SOSL query is the most efficient approach for implementing custom search functionality that spans multiple objects."
    },
    {
      
      "question": "A developer needs to implement a solution that requires access to deleted records in the Recycle Bin. Which API should be used?",
      "options": [
        "SOAP API",
        "REST API",
        "Bulk API",
        "Metadata API",
        "Tooling API"
      ],
      "correctAnswer": ["SOAP API"],
      "explanation": "The SOAP API provides the queryAll() call that can be used to access deleted records that are in the Recycle Bin. This feature is not available in the REST API or other APIs, making SOAP API the appropriate choice for this requirement."
    },
    {
      
      "question": "A developer is implementing complex transaction logic that needs to handle errors gracefully and provide detailed information to the user about which operations failed. Which approach should be used?",
      "options": [
        "Use Database methods with the allOrNone parameter set to false",
        "Use ApexPages.addMessage() to display errors",
        "Implement custom exception handling with try-catch blocks",
        "Use the SaveResult class to track errors",
        "Implement the AuraHandledException class"
      ],
      "correctAnswer": ["Use Database methods with the allOrNone parameter set to false"],
      "explanation": "Database methods (like Database.insert(), Database.update(), etc.) with the allOrNone parameter set to false allow partial success of operations. This approach provides detailed error information for failed records while allowing successful records to be processed, which supports complex transaction logic with graceful error handling."
    },
    {
      
      "question": "A developer needs to implement a solution where changes to records in Salesforce automatically update related records in an external system. Which two features can be used to implement this solution?",
      "options": [
        "Outbound Message with Workflow",
        "Change Data Capture",
        "Process Builder with External Services",
        "Apex callout with trigger",
        "Lightning Sync"
      ],
      "correctAnswer": ["Outbound Message with Workflow", "Change Data Capture"],
      "explanation": "Outbound Messages with Workflow can send SOAP messages to external endpoints when records change. Change Data Capture publishes change events that external systems can subscribe to. Both features provide mechanisms for automatically updating external systems when Salesforce records change, without requiring custom Apex code."
    },
    {
      
      "question": "A developer is designing a solution that needs to process records asynchronously and in a specific order. Which feature should be used?",
      "options": [
        "Batch Apex with Database.Stateful",
        "Scheduled Apex with Time-Based Workflow",
        "Queueable Apex with chaining",
        "@future methods with continuation",
        "Platform Events with ordered delivery"
      ],
      "correctAnswer": ["Queueable Apex with chaining"],
      "explanation": "Queueable Apex allows for chaining, where one job can enqueue another job after it completes. This provides a way to process records asynchronously in a specific order, as each job in the chain will only execute after the previous job has completed."
    },
    {
      
      "question": "A developer needs to create a solution that stores configuration data accessible across multiple apps but doesn't require code changes when the data changes. Which feature should be used?",
      "options": [
        "Custom Settings",
        "Custom Metadata Types",
        "Static Resources",
        "Platform Cache",
        "External Services"
      ],
      "correctAnswer": ["Custom Metadata Types"],
      "explanation": "Custom Metadata Types are ideal for storing configuration data that needs to be accessible across multiple apps. Unlike Custom Settings, Custom Metadata Types can be included in packages and deployed between environments, making them more suitable for configuration that should be environment-agnostic. They also don't require code changes when the data changes."
    },
    {
      
      "question": "A developer needs to implement custom UI components that can be reused across multiple pages and applications. Which feature would be most appropriate?",
      "options": [
        "Visualforce Components",
        "Lightning Web Components",
        "Custom HTML with Static Resources",
        "Flow Screens",
        "Aura Components"
      ],
      "correctAnswer": ["Lightning Web Components"],
      "explanation": "Lightning Web Components (LWC) is Salesforce's modern UI framework that allows developers to build efficient, reusable UI components using web standards. LWCs offer better performance, smaller payloads, and easier interoperability with other web technologies compared to Visualforce or Aura Components."
    },
    {
      
      "question": "A developer needs to implement a solution that requires validating data against an external system before saving a record. Which approach provides the most real-time validation?",
      "options": [
        "Use a validation rule with a custom formula",
        "Implement an Apex trigger with a callout",
        "Use Process Builder with an invocable method",
        "Create a Flow with an external service",
        "Use an @future method in a before trigger"
      ],
      "correctAnswer": ["Implement an Apex trigger with a callout"],
      "explanation": "A callout from an Apex trigger (specifically, from a future method or queueable class called by the trigger) allows for real-time validation against an external system before saving a record. While @future methods are asynchronous, a properly implemented callout from a trigger can provide synchronous validation when needed."
    },
    {
      
      "question": "A developer needs to implement a solution that handles high-volume data imports with complex processing requirements. Which implementation should be used?",
      "options": [
        "Data Loader with Workflow Rules",
        "Bulk API with Batch Apex",
        "REST API with @future methods",
        "Import Wizard with Process Builder",
        "CSV import with Flow"
      ],
      "correctAnswer": ["Bulk API with Batch Apex"],
      "explanation": "The Bulk API is specifically designed for processing large data volumes efficiently. Combined with Batch Apex for custom processing logic, this approach provides the best solution for high-volume data imports with complex processing requirements. The Bulk API automatically handles chunking, parallelization, and governor limit considerations."
    },
    {
      
      "question": "A developer needs to implement a solution to handle integration with an unreliable external system that occasionally fails to process requests. Which pattern should be implemented?",
      "options": [
        "Circuit Breaker Pattern",
        "Retry Pattern",
        "Publish-Subscribe Pattern",
        "Command Pattern",
        "Façade Pattern"
      ],
      "correctAnswer": ["Retry Pattern"],
      "explanation": "The Retry Pattern is appropriate when dealing with an unreliable external system. This pattern involves automatically retrying a failed operation with an incremental back-off strategy to give the external system time to recover, which increases the chance of successful integration despite occasional failures."
    },
    {
      
      "question": "A developer needs to create a solution where data from multiple sources is combined and transformed before being presented to users. Which approach should be used?",
      "options": [
        "Use SOQL aggregate functions",
        "Implement a rollup summary field",
        "Create a custom ETL solution with Batch Apex",
        "Use Platform Events with transformations",
        "Implement Connected Apps"
      ],
      "correctAnswer": ["Create a custom ETL solution with Batch Apex"],
      "explanation": "For complex data integration scenarios involving multiple sources, transformation, and consolidation, a custom ETL (Extract, Transform, Load) solution using Batch Apex is appropriate. This approach provides the flexibility to handle various data sources, apply complex transformations, and load the processed data for user presentation."
    },
    {
      
      "question": "A developer needs to implement a solution to monitor changes to specific fields on Contact records and maintain a history of changes. Which approach requires the least custom development?",
      "options": [
        "Create an Apex trigger to track field changes",
        "Use Field History Tracking",
        "Implement a custom object with Process Builder",
        "Use Platform Events with Change Data Capture",
        "Create a custom Visualforce page with controller"
      ],
      "correctAnswer": ["Use Field History Tracking"],
      "explanation": "Field History Tracking is a built-in feature that allows tracking changes to specific fields on standard and custom objects. It requires minimal setup (enabling tracking and selecting fields) and no custom development, making it the approach that requires the least custom development effort."
    },
    {
      
      "question": "A developer needs to implement a solution where an action in one Lightning web component affects multiple other components on the same page. Which communication mechanism should be used?",
      "options": [
        "Use @api decorated properties",
        "Implement Lightning Message Service",
        "Use Apex controllers with static variables",
        "Create an Event Bus component",
        "Use navigateToComponent with state parameters"
      ],
      "correctAnswer": ["Implement Lightning Message Service"],
      "explanation": "Lightning Message Service (LMS) is designed to facilitate communication between components on the same page, regardless of the framework (Aura, LWC, or Visualforce). It provides a publish-subscribe model that allows multiple components to react to events without being directly coupled to each other."
    },
    {
      
      "question": "A developer needs to implement a data model for a new application that handles customer support cases. Which relationship type should be used between Case and Customer objects?",
      "options": [
        "Master-Detail relationship",
        "Lookup relationship",
        "Many-to-Many relationship",
        "External lookup relationship",
        "Indirect lookup relationship"
      ],
      "correctAnswer": ["Lookup relationship"],
      "explanation": "A Lookup relationship is appropriate between Case and Customer objects because a Case is typically related to a Customer, but the Case can exist independently of the Customer record (for example, anonymous cases). This provides the flexibility needed for a customer support application while maintaining referential integrity."
    },
    {
      
      "question": "A developer needs to implement role-based access control for a custom application. Which approach provides the most flexible security model?",
      "options": [
        "Use field-level security and page layouts",
        "Implement custom permissions and permission sets",
        "Use record-level sharing rules and roles",
        "Implement Apex sharing reasons and manual sharing",
        "Use profiles with custom object permissions"
      ],
      "correctAnswer": ["Implement custom permissions and permission sets"],
      "explanation": "Custom permissions combined with permission sets provide a highly flexible approach to role-based access control. Custom permissions can be checked in code, components, and formulas to control feature access, while permission sets allow for modular assignment of these permissions to users, supporting complex role hierarchies without requiring profile duplication."
    },
    {
      
      "question": "A developer needs to implement a solution that requires processing large amounts of data across multiple related objects with complex business logic. Which feature would be most appropriate?",
      "options": [
        "Flow with subflows",
        "Process Builder with multiple criteria",
        "Custom Lightning Component with Apex controller",
        "Batch Apex with Database.Stateful",
        "Triggers with helper classes"
      ],
      "correctAnswer": ["Batch Apex with Database.Stateful"],
      "explanation": "Batch Apex with Database.Stateful is well-suited for processing large volumes of data across multiple objects. The batching mechanism handles chunking to avoid governor limits, while Database.Stateful allows maintaining state across batches for implementing complex business logic and tracking cross-batch metrics."
    },
    {
      
      "question": "A developer needs to implement a solution where changes to certain fields on an Account trigger processing in an external system, but only during business hours. Which approach should be used?",
      "options": [
        "Implement a scheduled Apex job",
        "Use time-based workflow with outbound messages",
        "Create a process with scheduled actions",
        "Use Platform Events with a time filter",
        "Implement a trigger with time-based logic"
      ],
      "correctAnswer": ["Create a process with scheduled actions"],
      "explanation": "Process Builder with scheduled actions allows for field change detection and scheduling actions to occur only during specified hours. This approach supports the requirement to trigger external system processing based on field changes but only during business hours, without requiring complex custom time-based logic."
    },
    {
      
      "question": "A developer needs to implement a custom approval process that requires dynamic routing based on record attributes and related object data. Which approach should be used?",
      "options": [
        "Use standard approval processes with entry criteria",
        "Implement a custom Flow with approval actions",
        "Create an Apex class that implements the Approval Process interface",
        "Use Process Builder with approval process actions",
        "Implement custom approval logic in Apex triggers"
      ],
      "correctAnswer": ["Implement custom approval logic in Apex triggers"],
      "explanation": "For complex approval scenarios requiring dynamic routing based on record attributes and related data, custom approval logic in Apex triggers provides the most flexibility. This approach allows for implementing sophisticated business rules that may not be possible with standard approval processes or declarative tools."
    },
    {
      
      "question": "A developer has implemented a Lightning web component that needs to securely store sensitive information on the client side for the duration of a user's session. Which approach should be used?",
      "options": [
        "Store the data in a Lightning component attribute",
        "Use the browser's localStorage",
        "Implement a secure browser cookie",
        "Use the Lightning Data Service",
        "Store the data in a hidden form field"
      ],
      "correctAnswer": ["Store the data in a Lightning component attribute"],
      "explanation": "Component attributes in Lightning Web Components are stored in memory and are isolated to the component's scope, making them appropriate for storing sensitive information for the duration of a user's session without persisting it to storage. This approach keeps the data secure while maintaining it for the needed timeframe."
    },
    {
      
      "question": "A developer needs to implement a solution to prevent duplicate Person Account records based on email address. Which approach should be used?",
      "options": [
        "Create a unique field constraint on the email field",
        "Implement a duplicate rule with matching rule",
        "Use an Apex trigger with a SOQL query",
        "Implement validation rules with cross-object formulas",
        "Use Process Builder with record-triggered flow"
      ],
      "correctAnswer": ["Implement a duplicate rule with matching rule"],
      "explanation": "Duplicate rules with matching rules provide a flexible and declarative approach to prevent duplicate records. For Person Accounts, a matching rule can be configured to identify potential duplicates based on email address, and the duplicate rule can be set to block the creation of duplicate records or alert users about potential duplicates."
    },
    {
      
      "question": "A developer needs to create a solution that displays data from an external system in a Lightning component. The data needs to be refreshed automatically every 5 minutes. Which approach should be used?",
      "options": [
        "Use the refreshApex method with a timer",
        "Implement a Lightning Data Service watcher",
        "Create a Platform Event subscriber",
        "Use a Streaming API PushTopic",
        "Implement a polling mechanism with setInterval"
      ],
      "correctAnswer": ["Implement a polling mechanism with setInterval"],
      "explanation": "For automatic refreshing of data from an external system at regular intervals (such as every 5 minutes), implementing a polling mechanism using JavaScript's setInterval function is appropriate. This approach allows the component to periodically request fresh data from the external system without requiring user interaction."
    },
    {
      
      "question": "A developer needs to implement a custom search interface that returns results as the user types, without requiring a full page refresh. Which technology combination should be used?",
      "options": [
        "Lightning Web Components with @wire service",
        "Visualforce with ActionFunction",
        "Aura Components with lightning:input",
        "Lightning Flow with Dynamic Choices",
        "Quick Actions with predefined filters"
      ],
      "correctAnswer": ["Lightning Web Components with @wire service"],
      "explanation": "Lightning Web Components with the @wire service provides a reactive data-fetching mechanism that can be triggered as the user types. This combination supports building a responsive search interface that updates results without page refreshes, with the @wire service handling the data fetching and component re-rendering."
    },
    {
      
      "question": "A developer needs to implement a solution that processes records in parallel with maximum performance. Which limitation must be considered?",
      "options": [
        "Parallel Apex executions are limited to 5 concurrent requests per organization",
        "Future methods are limited to 50 per Apex invocation",
        "Queueable jobs are limited to 50 jobs per transaction",
        "Batch Apex is limited to 5 concurrent batches",
        "Platform Events are limited to 100 events per transaction"
      ],
      "correctAnswer": ["Batch Apex is limited to 5 concurrent batches"],
      "explanation": "When implementing parallel processing with Batch Apex, developers must consider that there's a limit of 5 concurrent batch jobs running simultaneously per organization. This limit affects the design of solutions that require high parallelism and maximum performance."
    },
    {
      
      "question": "A developer needs to implement a solution that requires deploying changes to multiple environments with different configurations. Which approach should be used?",
      "options": [
        "Use Change Sets with deployment connections",
        "Implement a CI/CD pipeline with the Metadata API",
        "Use custom settings with environment-specific values",
        "Create packages with install handlers",
        "Use Sandbox templates with post-copy scripts"
      ],
      "correctAnswer": ["Implement a CI/CD pipeline with the Metadata API"],
      "explanation": "For complex deployments across multiple environments with different configurations, a CI/CD (Continuous Integration/Continuous Deployment) pipeline using the Metadata API provides the most robust solution. This approach allows for automated, version-controlled deployments with environment-specific configurations managed through variables or configuration files."
    },
    {
      
      "question": "A developer needs to implement a solution where a custom button on a Lightning record page performs complex operations involving multiple objects. Which approach should be used?",
      "options": [
        "Lightning Action with JavaScript controller",
        "Quick Action with predefined fields",
        "Lightning Web Component with imperative Apex",
        "Global Action with custom parameters",
        "Visualforce page with custom controller"
      ],
      "correctAnswer": ["Lightning Web Component with imperative Apex"],
      "explanation": "A Lightning Web Component with imperative Apex provides the flexibility needed for implementing complex operations across multiple objects. The component can include a button that, when clicked, calls an Apex method imperatively (on-demand) to perform the required operations with full access to the server-side capabilities."
    }
    