[
  {
    "topic": "Salesforce Fundamentals",
    "question": "What is the relationship between objects and records in Salesforce?",
    "type": "single",
    "options": [
      "Objects are instances of records",
      "Objects define the structure for records",
      "Records and objects are the same thing",
      "Records define the fields for objects"
    ],
    "correct": ["Objects define the structure for records"],
    "explanation": "In Salesforce, objects are like database tables that define the structure (fields, relationships, etc.) for records. Records are individual instances of an object, similar to rows in a database table."
  },
  {
    "topic": "Salesforce Fundamentals",
    "question": "What is the difference between standard and custom objects?",
    "type": "single",
    "options": [
      "Standard objects are created by users, custom objects by Salesforce",
      "Standard objects are provided by Salesforce, custom objects are created by users",
      "Standard objects cannot be modified, custom objects can",
      "Standard objects are for leads and opportunities only, custom objects for everything else"
    ],
    "correct": ["Standard objects are provided by Salesforce, custom objects are created by users"],
    "explanation": "Standard objects (like Account, Contact, Opportunity) are provided by Salesforce and included in the platform. Custom objects are created by organizations to store information specific to their business needs."
  },
  {
    "topic": "Salesforce Fundamentals",
    "question": "Which of the following are standard objects in Salesforce? (Select all that apply)",
    "type": "multiple",
    "options": [
      "Account",
      "Contact",
      "Employee__c",
      "Project__c"
    ],
    "correct": ["Account", "Contact"],
    "explanation": "Account and Contact are standard objects provided by Salesforce. Objects with the '__c' suffix like Employee__c and Project__c are custom objects created by users."
  },
  {
    "topic": "Salesforce Fundamentals",
    "question": "What is a key characteristic of a lookup relationship in Salesforce?",
    "type": "single",
    "options": [
      "It creates a tight coupling where the child record cannot exist without the parent",
      "It enables a many-to-many relationship between two objects",
      "It creates a loose coupling where related records can exist independently",
      "It automatically includes roll-up summary fields"
    ],
    "correct": ["It creates a loose coupling where related records can exist independently"],
    "explanation": "A lookup relationship creates a loose coupling between objects where related records can exist independently. Unlike master-detail relationships, deleting a parent record doesn't automatically delete the child records."
  },
  {
    "topic": "Salesforce Fundamentals",
    "question": "What uniquely identifies a record in Salesforce?",
    "type": "single",
    "options": [
      "Record Name",
      "Primary Key",
      "RecordId field",
      "15 or 18 character ID"
    ],
    "correct": ["15 or 18 character ID"],
    "explanation": "Each record in Salesforce is uniquely identified by a 15 or 18 character ID (the longer version is case-insensitive). This is automatically generated by Salesforce when a record is created."
  },
  {
    "topic": "Salesforce Fundamentals",
    "question": "Which of the following are characteristics of a master-detail relationship? (Select all that apply)",
    "type": "multiple",
    "options": [
      "The detail record cannot exist without the master",
      "Deleting the master record automatically deletes the detail records",
      "The master record inherits security settings from the detail record",
      "Roll-up summary fields can be created on the master object"
    ],
    "correct": ["The detail record cannot exist without the master", "Deleting the master record automatically deletes the detail records", "Roll-up summary fields can be created on the master object"],
    "explanation": "In a master-detail relationship: detail records cannot exist without their master record, deleting the master cascades to the details, and the master can have roll-up summary fields. The security flows from master to detail, not the other way around."
  },
  {
    "topic": "Salesforce Fundamentals",
    "question": "What feature uses relationship fields to display related lists on page layouts?",
    "type": "single",
    "options": [
      "Roll-up summary fields",
      "Custom tabs",
      "Related lists",
      "Junction objects"
    ],
    "correct": ["Related lists"],
    "explanation": "Related lists use relationship fields to display related records on page layouts. For example, a Contact page can show a related list of Cases associated with that Contact."
  },
  {
    "topic": "Data Management",
    "question": "What is SOQL used for in Salesforce?",
    "type": "single",
    "options": [
      "To search for records that match specific text",
      "To define data validation rules",
      "To query and retrieve specific records from the database",
      "To update multiple records simultaneously"
    ],
    "correct": ["To query and retrieve specific records from the database"],
    "explanation": "SOQL (Salesforce Object Query Language) is used to search for and retrieve specific records from the Salesforce database. It's similar to SQL but designed specifically for Salesforce data operations."
  },
  {
    "topic": "Data Management",
    "question": "What is the difference between SOQL and SOSL?",
    "type": "single",
    "options": [
      "SOQL is for admins, SOSL is for developers",
      "SOQL queries one object at a time, SOSL can search across multiple objects",
      "SOQL is for retrieving data, SOSL is for updating data",
      "SOQL is declarative, SOSL is programmatic"
    ],
    "correct": ["SOQL queries one object at a time, SOSL can search across multiple objects"],
    "explanation": "SOQL (Salesforce Object Query Language) queries one object at a time and returns specific records. SOSL (Salesforce Object Search Language) can search across multiple objects simultaneously for specific text."
  },
  {
    "topic": "Data Management",
    "question": "Which of the following is a valid SOQL query?",
    "type": "single",
    "options": [
      "SELECT Id, Name, Email FROM Lead WHERE Status = 'Open'",
      "SELECT Lead.Id, Lead.Name FROM Lead WHERE Lead.Status = 'Open'",
      "FIND 'Smith' IN Name FIELDS RETURNING Contact",
      "SELECT COUNT() FROM Contact GROUP BY AccountId"
    ],
    "correct": ["SELECT Id, Name, Email FROM Lead WHERE Status = 'Open'"],
    "explanation": "This is a valid SOQL query that will retrieve the Id, Name, and Email fields from Lead records where the Status is 'Open'. The second option incorrectly prefixes field names with the object name, the third is SOSL not SOQL, and the fourth has incorrect grouping syntax."
  },
  {
    "topic": "Data Management",
    "question": "Which governor limit applies to SOQL queries in a single Apex transaction?",
    "type": "single",
    "options": [
      "50 queries",
      "100 queries",
      "150 queries",
      "200 queries"
    ],
    "correct": ["100 queries"],
    "explanation": "In a single Apex transaction, you can execute up to 100 SOQL queries. This is one of Salesforce's governor limits to ensure system resources are used efficiently."
  },
  {
    "topic": "Data Management",
    "question": "What is the correct way to perform a SOQL query in Apex that returns multiple records?",
    "type": "single",
    "options": [
      "List<Account> accts = SELECT Id, Name FROM Account;",
      "List<Account> accts = [SELECT Id, Name FROM Account];",
      "List<Account> accts = query('SELECT Id, Name FROM Account');",
      "List<Account> accts = Database.query('SELECT Id, Name FROM Account');"
    ],
    "correct": ["List<Account> accts = [SELECT Id, Name FROM Account];"],
    "explanation": "In Apex, SOQL queries are enclosed in square brackets [] to retrieve multiple records. The format is List<ObjectType> variableName = [SOQL query];"
  },
  {
    "topic": "Data Management",
    "question": "What is the best practice for handling DML operations in Apex?",
    "type": "single",
    "options": [
      "Perform DML operations inside loops for immediate updates",
      "Use synchronous DML for large data volumes",
      "Bulkify DML operations by collecting records in a list and performing DML outside loops",
      "Always use individual DML statements for each record"
    ],
    "correct": ["Bulkify DML operations by collecting records in a list and performing DML outside loops"],
    "explanation": "The best practice is to bulkify DML operations by collecting records in a list and performing a single DML operation outside of loops. This helps avoid governor limits and improves performance."
  },
  {
    "topic": "Data Management",
    "question": "How many records can be processed in a single DML statement?",
    "type": "single",
    "options": [
      "100 records",
      "200 records",
      "10,000 records",
      "Depends on the specific governor limit"
    ],
    "correct": ["10,000 records"],
    "explanation": "A single DML statement can process up to 10,000 records at once in Salesforce. Attempting to process more will result in a governor limit exception."
  },
  {
    "topic": "Data Management",
    "question": "What is the difference between insert and Database.insert() in Apex?",
    "type": "single",
    "options": [
      "insert is faster, Database.insert() is more flexible",
      "insert can only handle one record, Database.insert() can handle multiple",
      "insert always fails if any record fails, Database.insert() can be configured to allow partial success",
      "insert is for admins, Database.insert() is for developers"
    ],
    "correct": ["insert always fails if any record fails, Database.insert() can be configured to allow partial success"],
    "explanation": "The key difference is that the insert DML operation always fails completely if any record fails, while Database.insert() can be configured to allow partial success with the allOrNone parameter set to false."
  },
  {
    "topic": "Data Management",
    "question": "Which of the following are valid DML operations in Apex? (Select all that apply)",
    "type": "multiple",
    "options": [
      "insert",
      "update",
      "merge",
      "modify"
    ],
    "correct": ["insert", "update", "merge"],
    "explanation": "insert, update, and merge are valid DML operations in Apex. 'modify' is not a valid DML operation in Salesforce."
  },
  {
    "topic": "Data Management",
    "question": "What is SOSL used for in Salesforce?",
    "type": "single",
    "options": [
      "To retrieve specific records from an object",
      "To perform text-based searches across multiple objects",
      "To update data across multiple objects",
      "To define relationships between objects"
    ],
    "correct": ["To perform text-based searches across multiple objects"],
    "explanation": "SOSL (Salesforce Object Search Language) is used to perform text-based searches across multiple objects simultaneously, similar to the global search functionality in the Salesforce UI."
  },
  {
    "topic": "Apex Basics",
    "question": "What is Apex in Salesforce?",
    "type": "single",
    "options": [
      "A declarative automation tool",
      "A proprietary programming language",
      "A database query language",
      "A visualization framework"
    ],
    "correct": ["A proprietary programming language"],
    "explanation": "Apex is Salesforce's proprietary programming language with a syntax similar to Java. It runs in a multi-tenant environment on the Salesforce platform and enables developers to execute flow and transaction control statements on the platform server."
  },
  {
    "topic": "Apex Basics",
    "question": "Which statement best describes the execution context of Apex?",
    "type": "single",
    "options": [
      "Apex always runs on the client side (browser)",
      "Apex runs on both client and server equally",
      "Apex runs on the Salesforce platform servers",
      "Apex runs on a dedicated virtual machine for each organization"
    ],
    "correct": ["Apex runs on the Salesforce platform servers"],
    "explanation": "Apex code runs entirely on the Salesforce platform servers in the cloud, not on the client side. This server-side execution ensures security and consistency across all clients."
  },
  {
    "topic": "Apex Basics",
    "question": "What are governor limits in Salesforce?",
    "type": "single",
    "options": [
      "Contractual limits on how many users can use Salesforce",
      "Restrictions on what administrators can customize",
      "Runtime limits that control resource usage and ensure platform health",
      "Limits on how many records can be stored in the database"
    ],
    "correct": ["Runtime limits that control resource usage and ensure platform health"],
    "explanation": "Governor limits are runtime limits imposed by Salesforce to ensure that applications run efficiently and don't monopolize shared resources in the multi-tenant environment."
  },
  {
    "topic": "Apex Basics",
    "question": "Which of the following are valid primitive data types in Apex? (Select all that apply)",
    "type": "multiple",
    "options": [
      "Integer",
      "String",
      "Boolean",
      "Object"
    ],
    "correct": ["Integer", "String", "Boolean"],
    "explanation": "Integer, String, and Boolean are valid primitive data types in Apex. 'Object' is not a primitive type in Apex, though there is an Object class for generic object handling."
  },
  {
    "topic": "Apex Basics",
    "question": "What does the keyword 'static' mean in an Apex class?",
    "type": "single",
    "options": [
      "The class cannot be modified after deployment",
      "The method or variable belongs to the class rather than an instance",
      "The method will run synchronously",
      "The variable value cannot be changed"
    ],
    "correct": ["The method or variable belongs to the class rather than an instance"],
    "explanation": "In Apex, 'static' means the method or variable belongs to the class itself, not to instances of the class. Static methods/variables can be used without creating an instance of the class."
  },
  {
    "topic": "Apex Basics",
    "question": "What is an Apex trigger?",
    "type": "single",
    "options": [
      "A scheduled job that runs at specific times",
      "A button that, when clicked, executes custom code",
      "Code that executes before or after a record is modified",
      "A declarative automation tool for administrators"
    ],
    "correct": ["Code that executes before or after a record is modified"],
    "explanation": "An Apex trigger is code that executes before or after records of a particular object are inserted, updated, deleted, or undeleted. Triggers are used to automate processes and enforce business rules."
  },
  {
    "topic": "Apex Basics",
    "question": "Which context variables are available in Apex triggers? (Select all that apply)",
    "type": "multiple",
    "options": [
      "Trigger.new",
      "Trigger.old",
      "Trigger.current",
      "Trigger.isExecuting"
    ],
    "correct": ["Trigger.new", "Trigger.old", "Trigger.isExecuting"],
    "explanation": "Trigger.new (list of new versions of records), Trigger.old (list of old versions of records), and Trigger.isExecuting (boolean flag) are valid trigger context variables. Trigger.current does not exist."
  },
  {
    "topic": "Apex Basics",
    "question": "Which statement about Apex test classes is correct?",
    "type": "single",
    "options": [
      "Test classes count toward an organization's code size limit",
      "Test methods must include at least one system assertion",
      "Test classes cannot access real data in the organization",
      "Salesforce recommends 75% or higher code coverage for deployments"
    ],
    "correct": ["Salesforce recommends 75% or higher code coverage for deployments"],
    "explanation": "Salesforce requires at least 75% code coverage for deployments, which is the recommended minimum. Test classes don't count toward code size limits, assertions aren't strictly required (though recommended), and tests can access real data with the 'SeeAllData' annotation (though not recommended)."
  },
  {
    "topic": "Apex Basics",
    "question": "How should Apex code handle potential errors?",
    "type": "single",
    "options": [
      "All errors should be caught and suppressed to ensure the code completes",
      "Use try-catch blocks to handle exceptions and provide appropriate error handling",
      "Always allow exceptions to propagate to the user interface",
      "Log all errors to a custom object instead of using exceptions"
    ],
    "correct": ["Use try-catch blocks to handle exceptions and provide appropriate error handling"],
    "explanation": "The best practice is to use try-catch blocks to catch exceptions and provide appropriate error handling, including user-friendly messages and logging where appropriate."
  },
  {
    "topic": "Apex Basics",
    "question": "What is the purpose of the @isTest annotation in Apex?",
    "type": "single",
    "options": [
      "To mark a class or method that should be executed only in the sandbox",
      "To identify code that contains unit tests for code coverage",
      "To indicate a method that should be exposed as a web service",
      "To exclude a method from governor limits"
    ],
    "correct": ["To identify code that contains unit tests for code coverage"],
    "explanation": "The @isTest annotation is used to identify classes or methods that contain test methods for code coverage. Test classes are not counted toward code size limits and operate under different governor limits."
  },
  {
    "topic": "Apex Classes",
    "question": "What is the difference between public and private access modifiers in Apex?",
    "type": "single",
    "options": [
      "Public classes can be called from triggers, private cannot",
      "Public methods can be accessed from other classes, private methods only within the declaring class",
      "Public variables can hold larger data volumes than private variables",
      "Public methods execute synchronously, private methods asynchronously"
    ],
    "correct": ["Public methods can be accessed from other classes, private methods only within the declaring class"],
    "explanation": "The 'public' access modifier makes methods and variables accessible from other classes, while 'private' restricts access to only within the class that declares them."
  },
  {
    "topic": "Apex Classes",
    "question": "Which access modifiers are available in Apex? (Select all that apply)",
    "type": "multiple",
    "options": [
      "public",
      "private",
      "protected",
      "readonly"
    ],
    "correct": ["public", "private", "protected"],
    "explanation": "Apex supports 'public', 'private', and 'protected' access modifiers. 'readonly' is not a valid access modifier in Apex."
  },
  {
    "topic": "Apex Classes",
    "question": "What is the purpose of an Apex constructor?",
    "type": "single",
    "options": [
      "To define variables that all methods in the class can access",
      "To initialize an object when it is created",
      "To establish connections to external systems",
      "To validate that a class has all required methods"
    ],
    "correct": ["To initialize an object when it is created"],
    "explanation": "An Apex constructor is a special method used to initialize objects when they are created (instantiated). It runs automatically when a new instance of a class is created using the 'new' keyword."
  },
  {
    "topic": "Apex Classes",
    "question": "How is method overloading implemented in Apex?",
    "type": "single",
    "options": [
      "By using the 'override' keyword",
      "By creating multiple methods with the same name but different parameters",
      "By extending a parent class and changing method behavior",
      "By using the '@overload' annotation"
    ],
    "correct": ["By creating multiple methods with the same name but different parameters"],
    "explanation": "Method overloading in Apex is implemented by creating multiple methods with the same name but different parameter types or numbers. Salesforce uses the parameters to determine which method to call."
  },
  {
    "topic": "Apex Classes",
    "question": "What is an abstract class in Apex?",
    "type": "single",
    "options": [
      "A class that cannot be modified once created",
      "A class that cannot be instantiated directly and may contain abstract methods",
      "A class that automatically connects to external systems",
      "A class that is automatically excluded from code coverage requirements"
    ],
    "correct": ["A class that cannot be instantiated directly and may contain abstract methods"],
    "explanation": "An abstract class in Apex cannot be instantiated directly, and it may contain abstract methods that must be implemented by any concrete subclass."
  },
  {
    "topic": "Apex Classes",
    "question": "What is the purpose of the 'this' keyword in Apex?",
    "type": "single",
    "options": [
      "To refer to the current execution context",
      "To refer to the current class instance",
      "To reference static variables",
      "To access private methods from outside a class"
    ],
    "correct": ["To refer to the current class instance"],
    "explanation": "The 'this' keyword in Apex refers to the current instance of the class. It's typically used to distinguish between instance variables and method parameters with the same name."
  },
  {
    "topic": "Apex Classes",
    "question": "What does the 'extends' keyword indicate in Apex?",
    "type": "single",
    "options": [
      "That a class gains additional storage capacity",
      "That a class inherits from another class",
      "That a class can exceed governor limits",
      "That a class contains extension methods"
    ],
    "correct": ["That a class inherits from another class"],
    "explanation": "The 'extends' keyword indicates that a class inherits from (is a subclass of) another class, gaining its non-private fields and methods."
  },
  {
    "topic": "Apex Classes",
    "question": "What is the correct way to instantiate a new instance of an Apex class?",
    "type": "single",
    "options": [
      "MyClass myInstance = create MyClass();",
      "MyClass myInstance = new MyClass();",
      "MyClass myInstance = MyClass.getInstance();",
      "MyClass myInstance = MyClass.constructor();"
    ],
    "correct": ["MyClass myInstance = new MyClass();"],
    "explanation": "The correct way to instantiate a new instance of an Apex class is to use the 'new' keyword followed by the class name and any constructor parameters: MyClass myInstance = new MyClass();"
  },
  {
    "topic": "Apex Classes",
    "question": "What is an interface in Apex?",
    "type": "single",
    "options": [
      "A type of visual component for the user interface",
      "A contract that specifies methods a class must implement",
      "A connection between Salesforce and external systems",
      "A special type of abstract class with only private methods"
    ],
    "correct": ["A contract that specifies methods a class must implement"],
    "explanation": "An interface in Apex is a contract or blueprint that defines methods a class must implement if it implements that interface. It enables polymorphism and standardizes how certain operations are performed."
  },
  {
    "topic": "Apex Collections",
    "question": "Which Apex collection type should be used when you need to ensure all elements are unique?",
    "type": "single",
    "options": [
      "List",
      "Array",
      "Set",
      "Map"
    ],
    "correct": ["Set"],
    "explanation": "A Set should be used when you need to ensure all elements are unique. Sets in Apex do not allow duplicate elements, and they are unordered collections."
  },
  {
    "topic": "Apex Collections",
    "question": "Which Apex collection types are available? (Select all that apply)",
    "type": "multiple",
    "options": [
      "List",
      "Set",
      "Map",
      "Array"
    ],
    "correct": ["List", "Set", "Map"],
    "explanation": "Apex has three main collection types: List (ordered collection), Set (unordered collection of unique elements), and Map (key-value pairs). Apex does not have a native Array type like some other languages."
  },
  {
    "topic": "Apex Collections",
    "question": "What is the correct way to initialize an empty List in Apex?",
    "type": "single",
    "options": [
      "List<String> myList = [];",
      "List<String> myList = new List();",
      "List<String> myList = new List<String>();",
      "String[] myList = [];"
    ],
    "correct": ["List<String> myList = new List<String>();"],
    "explanation": "The correct way to initialize an empty List in Apex is using the new keyword with the full generic type: List<String> myList = new List<String>();"
  },
  {
    "topic": "Apex Collections",
    "question": "What is the key characteristic of a Map in Apex?",
    "type": "single",
    "options": [
      "It stores data in a sequential order",
      "It prevents duplicate elements from being added",
      "It stores key-value pairs for efficient lookup",
      "It can only contain primitive data types"
    ],
    "correct": ["It stores key-value pairs for efficient lookup"],
    "explanation": "A Map in Apex stores key-value pairs for efficient lookup. Each key must be unique within the Map, and values are retrieved by referring to their associated key."
  },
  {
    "topic": "Apex Collections",
    "question": "What's the correct way to add an element to a List in Apex?",
    "type": "single",
    "options": [
      "myList.put('Element');",
      "myList.add('Element');",
      "myList.insert('Element');",
      "myList.push('Element');"
    ],
    "correct": ["myList.add('Element');"],
    "explanation": "The add() method is used to append an element to the end of a List in Apex."
  },
  {
    "topic": "Apex Collections",
    "question": "How do you add a key-value pair to a Map in Apex?",
    "type": "single",
    "options": [
      "myMap.add('key', 'value');",
      "myMap.put('key', 'value');",
      "myMap.set('key', 'value');",
      "myMap.insert('key', 'value');"
    ],
    "correct": ["myMap.put('key', 'value');"],
    "explanation": "The put() method is used to add a key-value pair to a Map in Apex. If the key already exists, its value will be updated."
  },
  {
    "topic": "Apex Collections",
    "question": "What is the difference between a List and a Set in Apex?",
    "type": "single",
    "options": [
      "Lists are ordered and allow duplicates, Sets are unordered and don't allow duplicates",
      "Lists are unordered, Sets are ordered",
      "Lists can only contain primitive types, Sets can contain any type",
      "Lists use integer indices, Sets use string keys"
    ],
    "correct": ["Lists are ordered and allow duplicates, Sets are unordered and don't allow duplicates"],
    "explanation": "The main differences between Lists and Sets are that Lists maintain the order of elements and allow duplicates, while Sets do not guarantee order and only contain unique elements."
  },
  {
    "topic": "Apex Collections",
    "question": "How do you check if a Set contains a specific element in Apex?",
    "type": "single",
    "options": [
      "mySet.has(element);",
      "mySet.includes(element);",
      "mySet.contains(element);",
      "mySet.exists(element);"
    ],
    "correct": ["mySet.contains(element);"],
    "explanation": "The contains() method is used to check if a Set contains a specific element in Apex, returning true if the element exists and false otherwise."
  },
  {
    "topic": "Apex Collections",
    "question": "What is the correct way to declare a Map with specific key and value types in Apex?",
    "type": "single",
    "options": [
      "Map myMap = new Map();",
      "Map<String, Account> myMap = new Map<String, Account>();",
      "Map(String, Account) myMap = new Map();",
      "Map<String:Account> myMap = new Map<String:Account>();"
    ],
    "correct": ["Map<String, Account> myMap = new Map<String, Account>();"],
    "explanation": "Maps in Apex must specify both key and value types using the generic syntax: Map<KeyType, ValueType>. The correct declaration specifies String as the key type and Account as the value type."
  },
  {
    "topic": "Apex Testing",
    "question": "What is the primary purpose of Apex unit tests?",
    "type": "single",
    "options": [
      "To ensure code executes efficiently",
      "To verify code behaves as expected and maintains quality",
      "To improve user experience",
      "To document code functionality"
    ],
    "correct": ["To verify code behaves as expected and maintains quality"],
    "explanation": "The primary purpose of Apex unit tests is to verify that code behaves as expected and to maintain code quality through automated validation. Tests help catch bugs and ensure code continues to work as changes are made."
  },
  {
    "topic": "Apex Testing",
    "question": "What minimum code coverage percentage is required for deploying Apex to production?",
    "type": "single",
    "options": [
      "50%",
      "75%",
      "85%",
      "100%"
    ],
    "correct": ["75%"],
    "explanation": "Salesforce requires a minimum of 75% code coverage for all Apex code before it can be deployed to a production environment. This helps ensure code quality and reliability."
  },
  {
    "topic": "Apex Testing",
    "question": "Which statement about test data in Apex tests is true?",
    "type": "single",
    "options": [
      "Tests should always use existing data from the organization",
      "Tests should create their own test data to ensure independence",
      "Test data is automatically generated by Salesforce",
      "Tests cannot access custom objects, only standard objects"
    ],
    "correct": ["Tests should create their own test data to ensure independence"],
    "explanation": "Best practice is for tests to create their own test data rather than relying on existing organizational data. This ensures tests are independent, reliable, and not affected by changes to organizational data."
  },
  {
    "topic": "Apex Testing",
    "question": "What does the @TestSetup annotation do in Apex test classes?",
    "type": "single",
    "options": [
      "Creates a sandbox environment for testing",
      "Marks a method that creates test data for multiple test methods to use",
      "Increases the governor limits for test execution",
      "Checks code coverage automatically"
    ],
    "correct": ["Marks a method that creates test data for multiple test methods to use"],
    "explanation": "The @TestSetup annotation marks a method that creates test data once, which can then be used by all test methods in the class. This improves efficiency by avoiding repeated data setup code."
  },
  {
    "topic": "Apex Testing",
    "question": "Which methods are used to verify expected behavior in Apex tests? (Select all that apply)",
    "type": "multiple",
    "options": [
      "System.assertEquals()",
      "System.assertNotEquals()",
      "System.verify()",
      "System.assertNull()"
    ],
    "correct": ["System.assertEquals()", "System.assertNotEquals()", "System.assertNull()"],
    "explanation": "System.assertEquals(), System.assertNotEquals(), and System.assertNull() are valid assertion methods in Apex tests. System.verify() is not a standard assertion method in Apex."
  },
  {
    "topic": "Apex Testing",
    "question": "What is the purpose of Test.startTest() and Test.stopTest() in Apex tests?",
    "type": "single",
    "options": [
      "To control when assertions are evaluated",
      "To measure execution time of test methods",
      "To reset governor limits and isolate the code under test",
      "To pause and resume test execution"
    ],
    "correct": ["To reset governor limits and isolate the code under test"],
    "explanation": "Test.startTest() and Test.stopTest() are used to reset governor limits before executing the code being tested, and to isolate that code's execution from the test setup. This ensures the code under test has a fresh set of governor limits."
  },
  {
    "topic": "Apex Testing",
    "question": "How can you test Apex code that makes callouts to external services?",
    "type": "single",
    "options": [
      "Disable callout testing as it's not required for coverage",
      "Use real callouts in test methods",
      "Use mock callouts with the HttpCalloutMock interface",
      "Only manual testing is supported for callouts"
    ],
    "correct": ["Use mock callouts with the HttpCalloutMock interface"],
    "explanation": "To test code that makes HTTP callouts, you must use mock callouts implemented with the HttpCalloutMock interface. Direct callouts are not allowed in test methods to ensure tests are self-contained and reliable."
  },
  {
    "topic": "Apex Testing",
    "question": "What does the @isTest(SeeAllData=true) annotation do?",
    "type": "single",
    "options": [
      "Allows test methods to run with elevated permissions",
      "Increases governor limits for the test method",
      "Allows the test to access all data in the organization",
      "Makes tests ignore validation rules"
    ],
    "correct": ["Allows the test to access all data in the organization"],
    "explanation": "The @isTest(SeeAllData=true) annotation allows a test class or method to access all data in the organization rather than just test data. However, this is generally discouraged as it makes tests dependent on organizational data."
  },
  {
    "topic": "Apex Testing",
    "question": "What is a best practice for writing effective Apex tests?",
    "type": "single",
    "options": [
      "Write a single test class for each Apex class",
      "Test only successful scenarios to ensure code works correctly",
      "Test both positive scenarios and edge cases/error conditions",
      "Always use SeeAllData=true to simplify testing"
    ],
    "correct": ["Test both positive scenarios and edge cases/error conditions"],
    "explanation": "A best practice for effective testing is to test both positive scenarios (when everything works as expected) and edge cases or error conditions (to ensure the code handles unexpected situations gracefully)."
  },
  {
    "topic": "Apex Triggers",
    "question": "What is an Apex trigger?",
    "type": "single",
    "options": [
      "A scheduled process that runs at specified intervals",
      "A user interface element that executes custom logic",
      "Code that executes before or after record operations",
      "An integration point between Salesforce and external systems"
    ],
    "correct": ["Code that executes before or after record operations"],
    "explanation": "An Apex trigger is code that executes automatically before or after record data operations (insert, update, delete, undelete) occur on a specific object."
  },
  {
    "topic": "Apex Triggers",
    "question": "Which operations can triggers respond to? (Select all that apply)",
    "type": "multiple",
    "options": [
      "Before Insert",
      "After Update",
      "Before Delete",
      "After Clone"
    ],
    "correct": ["Before Insert", "After Update", "Before Delete"],
    "explanation": "Triggers can respond to before and after versions of insert, update, delete, and undelete operations. 'After Clone' is not a standard trigger event in Salesforce."
  },
  {
    "topic": "Apex Triggers",
    "question": "When is a before trigger appropriate rather than an after trigger?",
    "type": "single",
    "options": [
      "When you need to modify the records being processed",
      "When you need to access related records",
      "When you need to use SOQL queries",
      "When you need maximum processing time"
    ],
    "correct": ["When you need to modify the records being processed"],
    "explanation": "Before triggers are appropriate when you need to modify or validate the records being processed before they're saved to the database. After triggers run after records are saved and have been assigned their system fields like Id."
  },
  {
    "topic": "Apex Triggers",
    "question": "What is the difference between Trigger.new and Trigger.newMap?",
    "type": "single",
    "options": [
      "Trigger.new is for insert, Trigger.newMap is for update",
      "Trigger.new is a List of records, Trigger.newMap is a Map with Id as the key",
      "Trigger.new contains only modified fields, Trigger.newMap contains all fields",
      "Trigger.new is for standard objects, Trigger.newMap is for custom objects"
    ],
    "correct": ["Trigger.new is a List of records, Trigger.newMap is a Map with Id as the key"],
    "explanation": "Trigger.new is a List of the records being processed, while Trigger.newMap is a Map with record Ids as keys and the record sObjects as values, making it easier to look up specific records by Id."
  },
  {
    "topic": "Apex Triggers",
    "question": "What is a best practice for organizing trigger logic?",
    "type": "single",
    "options": [
      "Put all logic directly in the trigger file",
      "Move complex logic to helper classes and call from the trigger",
      "Create separate triggers for each operation (insert, update, etc.)",
      "Use workflow rules instead of triggers whenever possible"
    ],
    "correct": ["Move complex logic to helper classes and call from the trigger"],
    "explanation": "Best practice is to keep triggers as thin as possible by moving complex logic to helper classes. This improves maintainability, testability, and makes the logic reusable outside the trigger context if needed."
  },
  {
    "topic": "Apex Triggers",
    "question": "Which trigger context variables are available in all trigger contexts? (Select all that apply)",
    "type": "multiple",
    "options": [
      "Trigger.new",
      "Trigger.old",
      "Trigger.isExecuting",
      "Trigger.operationType"
    ],
    "correct": ["Trigger.isExecuting", "Trigger.operationType"],
    "explanation": "Trigger.isExecuting and Trigger.operationType are available in all trigger contexts. Trigger.new is only available in insert, update, and undelete contexts, while Trigger.old is only available in update, delete, and undelete contexts."
  },
  {
    "topic": "Apex Triggers",
    "question": "What is recursion in the context of triggers, and why is it a concern?",
    "type": "single",
    "options": [
      "Calling the same method repeatedly, which can cause governor limit exceptions",
      "Having triggers call themselves indefinitely by updating their own object, which can cause infinite loops and stack overflows",
      "Executing DML operations inside loops, which is inefficient",
      "Using multiple triggers for the same object, which can cause permission issues"
    ],
    "correct": ["Having triggers call themselves indefinitely by updating their own object, which can cause infinite loops and stack overflows"],
    "explanation": "Trigger recursion occurs when a trigger updates records of the same object it's triggered on, potentially causing the trigger to fire again and again in an infinite loop. This can cause stack overflow errors and consume governor limits rapidly."
  },
  {
    "topic": "Apex Triggers",
    "question": "How can you prevent trigger recursion?",
    "type": "single",
    "options": [
      "By using the @future annotation",
      "By implementing a static boolean flag to track execution",
      "By using process builder instead of triggers",
      "By marking triggers as final"
    ],
    "correct": ["By implementing a static boolean flag to track execution"],
    "explanation": "A common pattern to prevent recursion is implementing a static boolean flag that gets set to true when the trigger runs, and checked before executing trigger logic. This ensures the trigger logic only executes once per transaction."
  },
  {
    "topic": "Apex Triggers",
    "question": "What is the correct syntax for defining a trigger?",
    "type": "single",
    "options": [
      "trigger MyTrigger on Account (before insert, after update) { }",
      "Trigger MyTrigger on Account (beforeInsert, afterUpdate) { }",
      "trigger MyTrigger for Account on (before insert, after update) { }",
      "Trigger on Account (before insert, after update) named MyTrigger { }"
    ],
    "correct": ["trigger MyTrigger on Account (before insert, after update) { }"],
    "explanation": "The correct syntax for defining a trigger is: trigger TriggerName on ObjectName (trigger_events) { code_block }. Events are specified as before/after followed by the operation."
  },
  {
    "topic": "Apex Triggers",
    "question": "Which operation can be prevented by a before trigger but not an after trigger?",
    "type": "single",
    "options": [
      "Record creation",
      "Field updates",
      "Record access",
      "Data integration"
    ],
    "correct": ["Record creation"],
    "explanation": "A before trigger can prevent record creation by adding validation errors to the record. After triggers run after the records have already been committed to the database, so they cannot prevent the operation that triggered them."
  },
  {
    "topic": "Visualforce",
    "question": "What is Visualforce used for in Salesforce?",
    "type": "single",
    "options": [
      "To create custom user interfaces",
      "To manage data models",
      "To automate business processes",
      "To define deployment procedures"
    ],
    "correct": ["To create custom user interfaces"],
    "explanation": "Visualforce is a markup language and framework used to create custom user interfaces that can be hosted natively on the Salesforce platform."
  },
  {
    "topic": "Visualforce",
    "question": "What is the relationship between a Visualforce page and an Apex controller?",
    "type": "single",
    "options": [
      "Visualforce pages automatically generate Apex controllers",
      "Apex controllers define the data and logic for Visualforce pages",
      "There is no relationship; they function independently",
      "Visualforce pages can only use standard controllers, not Apex"
    ],
    "correct": ["Apex controllers define the data and logic for Visualforce pages"],
    "explanation": "Apex controllers define the data and logic that Visualforce pages can access and use. They handle user interactions, data operations, and other logic needed for the page to function."
  },
  {
    "topic": "Visualforce",
    "question": "Which of the following are valid ways to include an Apex controller in a Visualforce page? (Select all that apply)",
    "type": "multiple",
    "options": [
      "Using a standard controller extension",
      "Using a custom controller",
      "Using a global controller",
      "Using a controller interface"
    ],
    "correct": ["Using a standard controller extension", "Using a custom controller"],
    "explanation": "Visualforce pages can use either custom controllers (completely custom Apex classes) or standard controller extensions (extending a standard object controller with custom logic). 'Global controller' and 'controller interface' are not standard Visualforce controller types."
  },
  {
    "topic": "Visualforce",
    "question": "What does the standardController attribute do in a Visualforce page?",
    "type": "single",
    "options": [
      "It makes the page appear in the standard Salesforce layout",
      "It provides automatic access to a standard object's data and behavior",
      "It enforces standard Salesforce styling",
      "It restricts the page to standard users only"
    ],
    "correct": ["It provides automatic access to a standard object's data and behavior"],
    "explanation": "The standardController attribute links a Visualforce page to a standard or custom object, providing automatic access to that object's data and standard behaviors like create, read, update, and delete operations."
  },
  {
    "topic": "Visualforce",
    "question": "How can a Visualforce page pass parameters to an Apex controller?",
    "type": "single",
    "options": [
      "Using the <apex:param> tag",
      "Through URL parameters automatically",
      "Via the param attribute in any Visualforce component",
      "Parameters cannot be passed from Visualforce to Apex"
    ],
    "correct": ["Using the <apex:param> tag"],
    "explanation": "The <apex:param> tag is used to pass parameters from a Visualforce page to an Apex controller, typically as part of an action method call or component."
  },
  {
    "topic": "Visualforce",
    "question": "Which of the following Visualforce components are used for data input? (Select all that apply)",
    "type": "multiple",
    "options": [
      "<apex:inputField>",
      "<apex:inputText>",
      "<apex:outputField>",
      "<apex:commandButton>"
    ],
    "correct": ["<apex:inputField>", "<apex:inputText>"],
    "explanation": "<apex:inputField> and <apex:inputText> are used for data input. <apex:outputField> is for displaying data, and <apex:commandButton> is for actions rather than data input directly."
  },
  {
    "topic": "Visualforce",
    "question": "What is the purpose of <apex:pageBlock> and <apex:pageBlockSection> in Visualforce?",
    "type": "single",
    "options": [
      "To control page access based on user profiles",
      "To organize content with standard Salesforce styling",
      "To display multiple Visualforce pages in tabs",
      "To restrict data access within a page"
    ],
    "correct": ["To organize content with standard Salesforce styling"],
    "explanation": "<apex:pageBlock> and <apex:pageBlockSection> are used to organize content on a Visualforce page with standard Salesforce styling, creating a familiar look and feel for users."
  },
  {
    "topic": "Visualforce",
    "question": "What is the correct way to include a Visualforce page in a standard page layout?",
    "type": "single",
    "options": [
      "Add it as a custom link on the page layout",
      "Create a Visualforce tab and add it to the app",
      "Add it as a Visualforce section in the page layout editor",
      "Use a custom button that redirects to the Visualforce page"
    ],
    "correct": ["Add it as a Visualforce section in the page layout editor"],
    "explanation": "To include a Visualforce page in a standard page layout, you add it as a Visualforce section using the page layout editor. This embeds the Visualforce page directly in the standard page layout."
  },
  {
    "topic": "Visualforce",
    "question": "What is view state in Visualforce?",
    "type": "single",
    "options": [
      "The visual design of the page",
      "Data stored client-side between requests to maintain component state",
      "User interface settings saved in Salesforce",
      "The URL parameters that determine what's displayed"
    ],
    "correct": ["Data stored client-side between requests to maintain component state"],
    "explanation": "View state in Visualforce is data stored client-side between server requests to maintain component state and values. It's automatically generated but has size limits that need to be considered for performance."
  },
  {
    "topic": "Visualforce",
    "question": "How can you optimize view state size in Visualforce? (Select all that apply)",
    "type": "multiple",
    "options": [
      "Use the transient keyword for variables that don't need to be part of view state",
      "Minimize the use of <apex:repeat> and other iteration components",
      "Use pagination for large data sets",
      "Store all data in JavaScript variables"
    ],
    "correct": ["Use the transient keyword for variables that don't need to be part of view state", "Minimize the use of <apex:repeat> and other iteration components", "Use pagination for large data sets"],
    "explanation": "To optimize view state: use the transient keyword for variables that don't need preservation, minimize component repetition, and use pagination instead of loading all data at once. Storing all data in JavaScript isn't a complete solution to view state issues."
  },
  {
    "topic": "Visualforce",
    "question": "What is the purpose of <apex:actionFunction> in Visualforce?",
    "type": "single",
    "options": [
      "To define JavaScript functions that can call Apex controller methods",
      "To automatically execute functions when the page loads",
      "To validate form inputs before submission",
      "To handle errors in Apex code"
    ],
    "correct": ["To define JavaScript functions that can call Apex controller methods"],
    "explanation": "<apex:actionFunction> defines a JavaScript function that can call an Apex method in the controller, enabling JavaScript to interact with server-side Apex code."
  },
  {
    "topic": "Integration",
    "question": "What is the primary purpose of the Salesforce REST API?",
    "type": "single",
    "options": [
      "To allow users to access Salesforce via mobile devices",
      "To integrate Salesforce with external systems and applications",
      "To improve database performance",
      "To enable declarative automation"
    ],
    "correct": ["To integrate Salesforce with external systems and applications"],
    "explanation": "The Salesforce REST API primarily enables integration between Salesforce and external systems by providing a standards-based, RESTful interface to Salesforce data and functionality."
  },
  {
    "topic": "Integration",
    "question": "Which authentication methods are supported by Salesforce APIs? (Select all that apply)",
    "type": "multiple",
    "options": [
      "OAuth 2.0",
      "Username and password with security token",
      "SAML assertion",
      "Anonymous access"
    ],
    "correct": ["OAuth 2.0", "Username and password with security token", "SAML assertion"],
    "explanation": "Salesforce APIs support OAuth 2.0, username-password with security token, and SAML assertion authentication methods. Anonymous access is not supported for security reasons."
  },
  {
    "topic": "Integration",
    "question": "What is a connected app in Salesforce?",
    "type": "single",
    "options": [
      "An app that connects different Salesforce organizations",
      "A framework that enables external applications to integrate with Salesforce via APIs",
      "A mobile application connected to Salesforce",
      "A third-party app available on AppExchange"
    ],
    "correct": ["A framework that enables external applications to integrate with Salesforce via APIs"],
    "explanation": "A connected app is a framework that enables external applications to integrate with Salesforce via APIs by defining how the external app can access Salesforce data through authentication and authorization."
  },
  {
    "topic": "Integration",
    "question": "What does the Apex HttpRequest class enable?",
    "type": "single",
    "options": [
      "Internal Salesforce communication",
      "Making callouts to external web services",
      "Handling HTTP requests from external systems",
      "Creating webhook endpoints"
    ],
    "correct": ["Making callouts to external web services"],
    "explanation": "The Apex HttpRequest class enables Salesforce to make outbound HTTP callouts to external web services and APIs, allowing Apex code to integrate with external systems."
  },
  {
    "topic": "Integration",
    "question": "Which component is required for Apex callouts to external web services?",
    "type": "single",
    "options": [
      "A site configuration",
      "A custom setting",
      "A remote site setting",
      "A custom metadata type"
    ],
    "correct": ["A remote site setting"],
    "explanation": "A remote site setting is required to allow Apex code to make callouts to external websites or services. This is a security feature that requires explicit administrator approval of external endpoints."
  },
  {
    "topic": "Integration",
    "question": "What is a disadvantage of using SOAP API compared to REST API?",
    "type": "single",
    "options": [
      "Less secure data transmission",
      "Fewer supported operations",
      "Higher bandwidth consumption and more complex implementation",
      "Lack of standardization"
    ],
    "correct": ["Higher bandwidth consumption and more complex implementation"],
    "explanation": "Compared to REST API, SOAP API typically has higher bandwidth consumption due to XML verbosity and more complex implementation requirements, though it offers strong typing and well-defined contracts."
  },
  {
    "topic": "Integration",
    "question": "How can an Apex class receive inbound webhook calls from external systems?",
    "type": "single",
    "options": [
      "By implementing the Webhook interface",
      "By using the @WebhookReceiver annotation",
      "By creating a class with a webservice method",
      "By exposing the class as a REST API endpoint with @RestResource"
    ],
    "correct": ["By exposing the class as a REST API endpoint with @RestResource"],
    "explanation": "To receive inbound webhook calls, an Apex class is exposed as a REST API endpoint using the @RestResource annotation, allowing external systems to send HTTP requests to the class."
  },
  {
    "topic": "Integration",
    "question": "What is the purpose of the Named Credential feature in Salesforce?",
    "type": "single",
    "options": [
      "To store user credentials for enhanced security",
      "To specify external endpoint details and authentication settings for callouts",
      "To grant specific permissions to integration users",
      "To create custom authentication providers"
    ],
    "correct": ["To specify external endpoint details and authentication settings for callouts"],
    "explanation": "Named Credentials store endpoint URLs and authentication details for external services, simplifying Apex callouts and centralizing credential management for better security and maintenance."
  },
  {
    "topic": "Integration",
    "question": "What are the benefits of using Named Credentials for external callouts? (Select all that apply)",
    "type": "multiple",
    "options": [
      "Simplified callout code without hardcoding endpoints",
      "Centralized credential management",
      "Support for different authentication protocols",
      "Automatic generation of API responses"
    ],
    "correct": ["Simplified callout code without hardcoding endpoints", "Centralized credential management", "Support for different authentication protocols"],
    "explanation": "Named Credentials provide simplified callout code without hardcoded endpoints, centralized credential management, and support for various authentication protocols. They don't automatically generate API responses."
  }
]